
package generatedAssertions.customAssertions;

import org.assertj.core.api.AbstractObjectAssert;
import org.assertj.core.internal.Iterables;
import org.assertj.core.util.Objects;
import org.springframework.samples.petclinic.model.Intervention;
import org.springframework.samples.petclinic.model.Specialty;
import org.springframework.samples.petclinic.model.User;
import org.springframework.samples.petclinic.model.Vet;

/**
 * Abstract base class for {@link Vet} specific assertions - Generated by CustomAssertionGenerator.
 */
@javax.annotation.Generated(value = "assertj-assertions-generator")
public abstract class AbstractVetAssert<S extends AbstractVetAssert<S, A>, A extends Vet> extends AbstractObjectAssert<S, A> {

	/**
	 * Creates a new <code>{@link AbstractVetAssert}</code> to make assertions on actual Vet.
	 *
	 * @param actual
	 *            the Vet we want to make assertions on.
	 */
	protected AbstractVetAssert(final A actual, final Class<S> selfType) {
		super(actual, selfType);
	}

	/**
	 * Verifies that the actual Vet's interventions contains the given Intervention elements.
	 *
	 * @param interventions
	 *            the given elements that should be contained in actual Vet's interventions.
	 * @return this assertion object.
	 * @throws AssertionError
	 *             if the actual Vet's interventions does not contain all given Intervention elements.
	 */
	public S hasInterventions(final Intervention... interventions) {
		// check that actual Vet we want to make assertions on is not null.
		this.isNotNull();

		// check that given Intervention varargs is not null.
		if (interventions == null) {
			this.failWithMessage("Expecting interventions parameter not to be null.");
		}

		// check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
		Iterables.instance().assertContains(this.info, this.actual.getInterventions(), interventions);

		// return the current assertion for method chaining
		return this.myself;
	}

	/**
	 * Verifies that the actual Vet's interventions contains the given Intervention elements in Collection.
	 *
	 * @param interventions
	 *            the given elements that should be contained in actual Vet's interventions.
	 * @return this assertion object.
	 * @throws AssertionError
	 *             if the actual Vet's interventions does not contain all given Intervention elements.
	 */
	public S hasInterventions(final java.util.Collection<? extends Intervention> interventions) {
		// check that actual Vet we want to make assertions on is not null.
		this.isNotNull();

		// check that given Intervention collection is not null.
		if (interventions == null) {
			this.failWithMessage("Expecting interventions parameter not to be null.");
			return this.myself; // to fool Eclipse "Null pointer access" warning on toArray.
		}

		// check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
		Iterables.instance().assertContains(this.info, this.actual.getInterventions(), interventions.toArray());

		// return the current assertion for method chaining
		return this.myself;
	}

	/**
	 * Verifies that the actual Vet's interventions contains <b>only</b> the given Intervention elements and nothing else in whatever order.
	 *
	 * @param interventions
	 *            the given elements that should be contained in actual Vet's interventions.
	 * @return this assertion object.
	 * @throws AssertionError
	 *             if the actual Vet's interventions does not contain all given Intervention elements.
	 */
	public S hasOnlyInterventions(final Intervention... interventions) {
		// check that actual Vet we want to make assertions on is not null.
		this.isNotNull();

		// check that given Intervention varargs is not null.
		if (interventions == null) {
			this.failWithMessage("Expecting interventions parameter not to be null.");
		}

		// check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
		Iterables.instance().assertContainsOnly(this.info, this.actual.getInterventions(), interventions);

		// return the current assertion for method chaining
		return this.myself;
	}

	/**
	 * Verifies that the actual Vet's interventions contains <b>only</b> the given Intervention elements in Collection and nothing else in whatever order.
	 *
	 * @param interventions
	 *            the given elements that should be contained in actual Vet's interventions.
	 * @return this assertion object.
	 * @throws AssertionError
	 *             if the actual Vet's interventions does not contain all given Intervention elements.
	 */
	public S hasOnlyInterventions(final java.util.Collection<? extends Intervention> interventions) {
		// check that actual Vet we want to make assertions on is not null.
		this.isNotNull();

		// check that given Intervention collection is not null.
		if (interventions == null) {
			this.failWithMessage("Expecting interventions parameter not to be null.");
			return this.myself; // to fool Eclipse "Null pointer access" warning on toArray.
		}

		// check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
		Iterables.instance().assertContainsOnly(this.info, this.actual.getInterventions(), interventions.toArray());

		// return the current assertion for method chaining
		return this.myself;
	}

	/**
	 * Verifies that the actual Vet's interventions does not contain the given Intervention elements.
	 *
	 * @param interventions
	 *            the given elements that should not be in actual Vet's interventions.
	 * @return this assertion object.
	 * @throws AssertionError
	 *             if the actual Vet's interventions contains any given Intervention elements.
	 */
	public S doesNotHaveInterventions(final Intervention... interventions) {
		// check that actual Vet we want to make assertions on is not null.
		this.isNotNull();

		// check that given Intervention varargs is not null.
		if (interventions == null) {
			this.failWithMessage("Expecting interventions parameter not to be null.");
		}

		// check with standard error message (use overridingErrorMessage before contains to set your own message).
		Iterables.instance().assertDoesNotContain(this.info, this.actual.getInterventions(), interventions);

		// return the current assertion for method chaining
		return this.myself;
	}

	/**
	 * Verifies that the actual Vet's interventions does not contain the given Intervention elements in Collection.
	 *
	 * @param interventions
	 *            the given elements that should not be in actual Vet's interventions.
	 * @return this assertion object.
	 * @throws AssertionError
	 *             if the actual Vet's interventions contains any given Intervention elements.
	 */
	public S doesNotHaveInterventions(final java.util.Collection<? extends Intervention> interventions) {
		// check that actual Vet we want to make assertions on is not null.
		this.isNotNull();

		// check that given Intervention collection is not null.
		if (interventions == null) {
			this.failWithMessage("Expecting interventions parameter not to be null.");
			return this.myself; // to fool Eclipse "Null pointer access" warning on toArray.
		}

		// check with standard error message (use overridingErrorMessage before contains to set your own message).
		Iterables.instance().assertDoesNotContain(this.info, this.actual.getInterventions(), interventions.toArray());

		// return the current assertion for method chaining
		return this.myself;
	}

	/**
	 * Verifies that the actual Vet has no interventions.
	 *
	 * @return this assertion object.
	 * @throws AssertionError
	 *             if the actual Vet's interventions is not empty.
	 */
	public S hasNoInterventions() {
		// check that actual Vet we want to make assertions on is not null.
		this.isNotNull();

		// we override the default error message with a more explicit one
		String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have interventions but had :\n  <%s>";

		// check
		if (this.actual.getInterventions().iterator().hasNext()) {
			this.failWithMessage(assertjErrorMessage, this.actual, this.actual.getInterventions());
		}

		// return the current assertion for method chaining
		return this.myself;
	}

	/**
	 * Verifies that the actual Vet's nrOfSpecialties is equal to the given one.
	 *
	 * @param nrOfSpecialties
	 *            the given nrOfSpecialties to compare the actual Vet's nrOfSpecialties to.
	 * @return this assertion object.
	 * @throws AssertionError
	 *             - if the actual Vet's nrOfSpecialties is not equal to the given one.
	 */
	public S hasNrOfSpecialties(final int nrOfSpecialties) {
		// check that actual Vet we want to make assertions on is not null.
		this.isNotNull();

		// overrides the default error message with a more explicit one
		String assertjErrorMessage = "\nExpecting nrOfSpecialties of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

		// check
		int actualNrOfSpecialties = this.actual.getNrOfSpecialties();
		if (actualNrOfSpecialties != nrOfSpecialties) {
			this.failWithMessage(assertjErrorMessage, this.actual, nrOfSpecialties, actualNrOfSpecialties);
		}

		// return the current assertion for method chaining
		return this.myself;
	}

	/**
	 * Verifies that the actual Vet's specialties contains the given Specialty elements.
	 *
	 * @param specialties
	 *            the given elements that should be contained in actual Vet's specialties.
	 * @return this assertion object.
	 * @throws AssertionError
	 *             if the actual Vet's specialties does not contain all given Specialty elements.
	 */
	public S hasSpecialties(final Specialty... specialties) {
		// check that actual Vet we want to make assertions on is not null.
		this.isNotNull();

		// check that given Specialty varargs is not null.
		if (specialties == null) {
			this.failWithMessage("Expecting specialties parameter not to be null.");
		}

		// check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
		Iterables.instance().assertContains(this.info, this.actual.getSpecialties(), specialties);

		// return the current assertion for method chaining
		return this.myself;
	}

	/**
	 * Verifies that the actual Vet's specialties contains the given Specialty elements in Collection.
	 *
	 * @param specialties
	 *            the given elements that should be contained in actual Vet's specialties.
	 * @return this assertion object.
	 * @throws AssertionError
	 *             if the actual Vet's specialties does not contain all given Specialty elements.
	 */
	public S hasSpecialties(final java.util.Collection<? extends Specialty> specialties) {
		// check that actual Vet we want to make assertions on is not null.
		this.isNotNull();

		// check that given Specialty collection is not null.
		if (specialties == null) {
			this.failWithMessage("Expecting specialties parameter not to be null.");
			return this.myself; // to fool Eclipse "Null pointer access" warning on toArray.
		}

		// check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
		Iterables.instance().assertContains(this.info, this.actual.getSpecialties(), specialties.toArray());

		// return the current assertion for method chaining
		return this.myself;
	}

	/**
	 * Verifies that the actual Vet's specialties contains <b>only</b> the given Specialty elements and nothing else in whatever order.
	 *
	 * @param specialties
	 *            the given elements that should be contained in actual Vet's specialties.
	 * @return this assertion object.
	 * @throws AssertionError
	 *             if the actual Vet's specialties does not contain all given Specialty elements.
	 */
	public S hasOnlySpecialties(final Specialty... specialties) {
		// check that actual Vet we want to make assertions on is not null.
		this.isNotNull();

		// check that given Specialty varargs is not null.
		if (specialties == null) {
			this.failWithMessage("Expecting specialties parameter not to be null.");
		}

		// check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
		Iterables.instance().assertContainsOnly(this.info, this.actual.getSpecialties(), specialties);

		// return the current assertion for method chaining
		return this.myself;
	}

	/**
	 * Verifies that the actual Vet's specialties contains <b>only</b> the given Specialty elements in Collection and nothing else in whatever order.
	 *
	 * @param specialties
	 *            the given elements that should be contained in actual Vet's specialties.
	 * @return this assertion object.
	 * @throws AssertionError
	 *             if the actual Vet's specialties does not contain all given Specialty elements.
	 */
	public S hasOnlySpecialties(final java.util.Collection<? extends Specialty> specialties) {
		// check that actual Vet we want to make assertions on is not null.
		this.isNotNull();

		// check that given Specialty collection is not null.
		if (specialties == null) {
			this.failWithMessage("Expecting specialties parameter not to be null.");
			return this.myself; // to fool Eclipse "Null pointer access" warning on toArray.
		}

		// check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
		Iterables.instance().assertContainsOnly(this.info, this.actual.getSpecialties(), specialties.toArray());

		// return the current assertion for method chaining
		return this.myself;
	}

	/**
	 * Verifies that the actual Vet's specialties does not contain the given Specialty elements.
	 *
	 * @param specialties
	 *            the given elements that should not be in actual Vet's specialties.
	 * @return this assertion object.
	 * @throws AssertionError
	 *             if the actual Vet's specialties contains any given Specialty elements.
	 */
	public S doesNotHaveSpecialties(final Specialty... specialties) {
		// check that actual Vet we want to make assertions on is not null.
		this.isNotNull();

		// check that given Specialty varargs is not null.
		if (specialties == null) {
			this.failWithMessage("Expecting specialties parameter not to be null.");
		}

		// check with standard error message (use overridingErrorMessage before contains to set your own message).
		Iterables.instance().assertDoesNotContain(this.info, this.actual.getSpecialties(), specialties);

		// return the current assertion for method chaining
		return this.myself;
	}

	/**
	 * Verifies that the actual Vet's specialties does not contain the given Specialty elements in Collection.
	 *
	 * @param specialties
	 *            the given elements that should not be in actual Vet's specialties.
	 * @return this assertion object.
	 * @throws AssertionError
	 *             if the actual Vet's specialties contains any given Specialty elements.
	 */
	public S doesNotHaveSpecialties(final java.util.Collection<? extends Specialty> specialties) {
		// check that actual Vet we want to make assertions on is not null.
		this.isNotNull();

		// check that given Specialty collection is not null.
		if (specialties == null) {
			this.failWithMessage("Expecting specialties parameter not to be null.");
			return this.myself; // to fool Eclipse "Null pointer access" warning on toArray.
		}

		// check with standard error message (use overridingErrorMessage before contains to set your own message).
		Iterables.instance().assertDoesNotContain(this.info, this.actual.getSpecialties(), specialties.toArray());

		// return the current assertion for method chaining
		return this.myself;
	}

	/**
	 * Verifies that the actual Vet has no specialties.
	 *
	 * @return this assertion object.
	 * @throws AssertionError
	 *             if the actual Vet's specialties is not empty.
	 */
	public S hasNoSpecialties() {
		// check that actual Vet we want to make assertions on is not null.
		this.isNotNull();

		// we override the default error message with a more explicit one
		String assertjErrorMessage = "\nExpecting :\n  <%s>\nnot to have specialties but had :\n  <%s>";

		// check
		if (this.actual.getSpecialties().iterator().hasNext()) {
			this.failWithMessage(assertjErrorMessage, this.actual, this.actual.getSpecialties());
		}

		// return the current assertion for method chaining
		return this.myself;
	}

	/**
	 * Verifies that the actual Vet's user is equal to the given one.
	 *
	 * @param user
	 *            the given user to compare the actual Vet's user to.
	 * @return this assertion object.
	 * @throws AssertionError
	 *             - if the actual Vet's user is not equal to the given one.
	 */
	public S hasUser(final User user) {
		// check that actual Vet we want to make assertions on is not null.
		this.isNotNull();

		// overrides the default error message with a more explicit one
		String assertjErrorMessage = "\nExpecting user of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";

		// null safe check
		User actualUser = this.actual.getUser();
		if (!Objects.areEqual(actualUser, user)) {
			this.failWithMessage(assertjErrorMessage, this.actual, user, actualUser);
		}

		// return the current assertion for method chaining
		return this.myself;
	}

}
